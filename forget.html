
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Forgot password</title>
  <style>
    :root{ --bg:#f4f7fb; --card:#fff; --accent:#2563eb; --muted:#6b7280; --danger:#dc2626; --radius:12px; font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, Arial; }
    html,body{height:100%}
    body{ margin:0; background:linear-gradient(180deg,#f8fafc 0%, #eef2ff 100%); display:flex; align-items:center; justify-content:center; padding:24px; }
    .card{ width:100%; max-width:420px; background:var(--card); border-radius:var(--radius); box-shadow:0 8px 30px rgba(20,30,60,0.08); padding:28px; border:1px solid rgba(15,23,42,0.04); }
    h1{margin:0 0 6px; font-size:1.25rem; color:#0f172a}
    p.lead{margin:0 0 18px; color:var(--muted); font-size:0.95rem}
    form{display:grid; gap:12px}
    label{font-size:0.85rem; color:#0f172a; margin-bottom:6px; display:block}
    .field{ display:flex; align-items:center; gap:8px; background:#fbfdff; border-radius:10px; padding:8px 10px; border:1px solid rgba(15,23,42,0.06); }
    input[type="email"]{border:0; outline:0; background:transparent; width:100%; font-size:0.98rem; color:#0f172a;}
    button.primary{width:100%; padding:10px 12px; border:0; border-radius:10px; background:var(--accent); color:#fff; font-weight:600; cursor:pointer;}
    .small{font-size:0.85rem; color:var(--muted); text-align:center; margin-top:12px}
    .error{color:var(--danger); font-size:0.85rem}
    .hidden{display:none}
    .success{display:flex; gap:12px; align-items:center; background:#eef2f6; color:#064e3b; padding:12px; border-radius:10px; border:1px solid rgba(4,120,87,0.06)}
    a.inline{color:var(--accent); text-decoration:none}
    .note{font-size:0.82rem; color:var(--muted); margin-top:6px}
  </style>
</head>
<body>
  <main class="card" role="main" aria-labelledby="title">
    <header>
      <h1 id="title">Forgot password?</h1>
      <p class="lead">Enter your email and we'll send a link to reset your password.</p>
    </header>

    <form id="forgetForm" novalidate>
      <div>
        <label for="email">Email</label>
        <div class="field">
          <input id="email" name="email" type="email" inputmode="email" autocomplete="email" placeholder="you@email.com" required>
        </div>
        <div id="emailError" class="error hidden" aria-live="polite"></div>
      </div>

      <div>
        <button id="submitBtn" class="primary" type="submit">Send reset link</button>
      </div>

      <div id="feedback" aria-live="polite" class="hidden"></div>

      <p class="small">
        Remembered? <a href="login.html" class="inline">Sign in</a> · <a href="signup.html" class="inline">Create account</a>
      </p>
      <p class="note"><strong>Demo:</strong> tokens are generated locally. In production, implement server-side rate limiting, hashed tokens, email delivery and HTTPS.</p>
    </form>
  </main>

  <script>
  (function(){
    // Keys used in localStorage for demo only
    const USERS_KEY = 'demo_users_v1';
    const TOKENS_KEY = 'demo_reset_tokens_v1';
    const ATTEMPTS_KEY = 'demo_reset_attempts_v1';
    const LOGS_KEY = 'demo_reset_logs_v1';

    const form = document.getElementById('forgetForm');
    const emailEl = document.getElementById('email');
    const emailError = document.getElementById('emailError');
    const feedback = document.getElementById('feedback');

    const emailPattern = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;

    // Rate-limit parameters (demo). MUST be enforced on server in production.
    const RATE_WINDOW_MS = 60 * 60 * 1000; // 1 hour
    const MAX_REQUESTS_PER_WINDOW = 5;

    function now(){ return Date.now(); }

    function showError(el,msg){ el.textContent = msg; el.classList.remove('hidden'); }
    function showFeedback(msg){ feedback.className = 'success'; feedback.textContent = msg; feedback.classList.remove('hidden'); }
    function clearMessages(){ [emailError, feedback].forEach(e => { e.textContent=''; e.classList.add('hidden'); }); }

    function getUsers(){ return JSON.parse(localStorage.getItem(USERS_KEY) || '[]'); }
    function getTokens(){ return JSON.parse(localStorage.getItem(TOKENS_KEY) || '[]'); }
    function setTokens(t){ localStorage.setItem(TOKENS_KEY, JSON.stringify(t)); }
    function getAttempts(){ return JSON.parse(localStorage.getItem(ATTEMPTS_KEY) || '{}'); }
    function setAttempts(a){ localStorage.setItem(ATTEMPTS_KEY, JSON.stringify(a)); }
    function appendLog(entry){ const logs = JSON.parse(localStorage.getItem(LOGS_KEY) || '[]'); logs.push(entry); localStorage.setItem(LOGS_KEY, JSON.stringify(logs)); }

    function pruneOldAttempts(attempts, cutoff){ return attempts.filter(ts => ts > cutoff); }

    function rateLimitCheck(email){
      // Track attempts per email (demo). Real server should rate-limit per IP/email and global.
      const attempts = getAttempts();
      const lower = (email || '').toLowerCase();
      const list = attempts[lower] || [];
      const cutoff = now() - RATE_WINDOW_MS;
      const recent = pruneOldAttempts(list, cutoff);

      if(recent.length >= MAX_REQUESTS_PER_WINDOW){
        // Log the blocked attempt
        appendLog({ ts: now(), email: lower, action: 'forgot_rate_limited', ua:navigator.userAgent });
        attempts[lower] = recent;
        setAttempts(attempts);
        return false;
      }

      recent.push(now());
      attempts[lower] = recent;
      setAttempts(attempts);
      return true;
    }

    // Create a cryptographically random token and return {token, hashed}
    async function createSecureToken(){
      const bytes = new Uint8Array(32); // 256-bit token
      crypto.getRandomValues(bytes);
      // token string safe for URLs: base64url
      const token = btoa(String.fromCharCode(...bytes)).replace(/\+/g,'-').replace(/\//g,'_').replace(/=+$/,'');
      const hashed = await sha256Hex(token);
      return { token, hashed };
    }

    async function sha256Hex(str){
      const enc = new TextEncoder().encode(str);
      const hashBuffer = await crypto.subtle.digest('SHA-256', enc);
      const hashArray = Array.from(new Uint8Array(hashBuffer));
      return hashArray.map(b => b.toString(16).padStart(2,'0')).join('');
    }

    form.addEventListener('submit', async (ev) => {
      ev.preventDefault();
      clearMessages();

      const email = (emailEl.value || '').trim();
      if(!email){
        showError(emailError, 'Email is required.');
        emailEl.focus();
        return;
      }
      if(!emailPattern.test(email)){
        showError(emailError, 'Enter a valid email.');
        emailEl.focus();
        return;
      }

      // Rate-limit check (demo)
      if(!rateLimitCheck(email)){
        // Generic response to avoid enumeration
        showFeedback('If an account exists for that email, a password reset link has been sent. Check your inbox.');
        return;
      }

      // Find user but do NOT reveal existence
      const users = getUsers();
      const lower = email.toLowerCase();
      const user = users.find(u => u.email && u.email.toLowerCase() === lower);

      if(user){
        // Create a single-use expiring token and store only its hash.
        const { token, hashed } = await createSecureToken();
        const tokens = getTokens();
        // remove previous tokens for same email (optional) — ensures single active token per email
        const filtered = tokens.filter(t => t.email !== lower || (t.expires && t.expires < now()));
        filtered.push({ email: lower, hashed, expires: now() + (60 * 60 * 1000), used: false }); // 1 hour expiry
        setTokens(filtered);

        // Log the issuance
        appendLog({ ts: now(), email: lower, action: 'reset_token_issued', ua:navigator.userAgent });

        // In demo: print token to console for testing. Do NOT expose this in production.
        console.info('Demo reset token (copy into reset page as ?t=...):', token);
        // Optionally build direct reset link for local testing:
        console.info('Local reset URL:', `${location.origin}${location.pathname.replace(/forget\.html$/,'reset.html')}?t=${encodeURIComponent(token)}`);
      } else {
        // Log a reset attempt for a non-existent email for monitoring
        appendLog({ ts: now(), email: lower, action: 'reset_attempt_no_account', ua:navigator.userAgent });
      }

      // Always show a generic response to the user to avoid enumeration
      showFeedback('If an account exists for that email, a password reset link has been sent. Check your inbox.');
      emailEl.value = '';
    });

    emailEl.addEventListener('input', () => {
      emailError.textContent = '';
      emailError.classList.add('hidden');
      feedback.textContent = '';
      feedback.classList.add('hidden');
    });

  })();
  </script>
</body>
</html>